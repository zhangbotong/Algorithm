### 题目

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

背包容量 = 4

|       | weight | value |
| ----- | ------ | ----- |
| 物品1 | 1      | 15    |
| 物品2 | 2      | 20    |
| 物品3 | 4      | 30    |

### 思路

本篇使用一维数组数据结构，是建立在二维数组基础上的优化。

n 件物品编号：1,2,...n

对应重量：w[i]

对应价值：v[i]

背包容量：b

数据结构：dp[j]--背包容量 j 的最大价值（其实在遍历物品 i 时暗含了在前 i 个物品取，但这里要注意递归公式的取值其实是暗含了dp[i - 1] 的，由于省略了一个维度，所以小心别取错）。

由于二维数组的递归公式：dp\[i][j] = Max(dp\[i - 1][j] ,  v[i] + dp\[i - 1][j - w[i]])，看到公式中只用到了上一行即 [i - 1] 这行的数据，因此可以优化空间，改为一维数组。

dp[j] = Max(dp[j], v[i] + dp[j - w[i]])，其中 

右侧 dp[j] = dp\[i - 1][j], 

dp[j - w[i]] = dp\[i - 1][j - w[i]]

因此，对遍历顺序要求多一些，才能保证上述两等式成立。

#### 遍历顺序分析

主要解决以下两等式：

* 左侧 dp[j] = dp\[i][j]
* 右侧 dp[j] = dp\[i - 1][j]

* dp[j - w[i]] = dp\[i - 1][j - w[i]]

从以下几个实际问题出发：

1. 物品 i 遍历顺序
2. 背包容量 j 遍历顺序
3. 物品与背包容量遍历的先后顺序

主要是以上 3 个顺序的排列组合。

首先看问题 1，i 依赖 i-1，所以物品一定是从前往后遍历；

##### 遍历顺序举例

1. 先物品后背包容量，物品从前往后，背包容量从后往前（）

   物品 1，背包容量 1：

2. 先背包容量后物品，物品从前往后，背包容量从后往前

#### 递归五部曲

1. dp[j] 数组下标及其含义 ：背包容量 j 的最大价值

2. 递归公式：dp[j] = Max(dp[j], v[i] + dp[j - w[i]])

3. dp 数组初始化

   | 物品/背包容量 | 容量0 | 容量1 | 容量2 | 容量3 |
   | ------------- | ----- | ----- | ----- | ----- |
   | 最大价值      | 0     | 0     | 0     | 0     |

4. 遍历顺序

   4.1 先物品后背包，物品从前往后，背包也从前往后

   **4.2 先物品后背包，物品从前往后，背包从后往前**

   4.3 先物品后背包，物品从后往前，背包从前往后

   4.4 先物品后背包，物品从后往前，背包也从后往前

   4.5 先背包后物品，背包从前往后，物品也从前往后

   4.6 先背包后物品，背包从前往后，物品从后往前

   4.7 先背包后物品，背包从后往前，物品从前往后

   4.8 先背包后物品，背包从后往前，物品也从后往前

   原则：联想二维表格，

   * **本行覆盖上一行**
   * **右下角依赖左上角**。

   虽然排列组合共有 8 种情况，但其实不必每种情况都分析一遍，可以排除掉一种条件后就排除了一半，即 log n 式，8 -> 4 -> 2 -> 1。

   先看物品和背包的顺序，由于是覆盖行，所以只能先遍历物品，因此 5、6、7、8 淘汰；

   再单看物品的遍历顺序，右下角依赖左上角，所以物品肯定不能从下往上遍历，那样依赖就不成立了，因此物品应从前往后，3、4 out。

   再看背包顺序，右下角依赖左上角，若是从前往后，后面的本来要依赖左上角，但是被本行的数据覆盖了，不成立。假如从后往前呢，哎刚好可以，perfect。因此 4.2 是唯一解。

   回过头再看二维数组，二维数组的原则只有一个：

   * 右下角依赖左上角

   因此，1、2、5 胜出。

   ##### 举例推导

   * **物品 1**

     * **背包容量 4，dp[4] = dp\[1][4] = 15**

       dp[4] = Max{dp[4], v[1] + dp[4 - w[1]]} = Max{**dp[4]**, v[1] + **dp[3]**} = Max{0, 15} = 15

       dp\[1][4] = Max{dp\[0][4], v[1] + dp\[0][4 - w[1]]} = Max{**dp\[0][4]**, v[1] + **dp\[0][3]**} = Max{0, 15} = 15

       右侧，dp[4] = dp\[0][4], dp[3] = dp\[0][3]。

     * **背包容量 3**，**dp[3] = dp\[1][3] = 15**

       dp[3] = Max{dp[3], v[1] + dp[3 - w[1]]} = Max{**dp[3]**, v[1] + **dp[2]**} = Max{0, 15} = 15

       dp\[1][3] = Max{dp\[0][3], v[1] + dp\[0][3 - w[1]]} = Max{**dp\[0][3]**, v[1] + **dp\[0][2]**} = Max{0, 15} = 15

       **右侧，dp[3] = dp\[0][3], dp[2] = dp\[0][2]。**

     * **背包容量 2**，**dp[2] = dp\[1][2] = 15**

       dp[2] = Max{dp[2], v[1] + dp[2 - w[1]]} = Max{**dp[2]**, v[1] + **dp[1]**} = Max{0, 15} = 15

       dp\[1][2] = Max{dp\[0][2], v[1] + dp\[0][2 - w[1]]} = Max{**dp\[0][2]**, v[1] + **dp\[0][1]**} = Max{0, 15} = 15

       **右侧，dp[2] = dp\[0][2] = 0, dp[1] = dp\[0][1] = 0**

     * **背包容量 1，dp[1] = dp\[1][1] = 15**

       dp[1] = Max{dp[1], v[1] + dp[1 - w[1]]} = Max{**dp[1]**, v[1] + **dp[0]**} = Max{0, 15} = 15

       dp\[1][1] = Max{dp\[0][1], v[1] + dp\[0][1 - w[2]]} = Max{**dp\[0][1]**, v[1] + **dp\[0][0]**} = Max{0, 15} = 15

       **右侧，dp[1] = dp\[0][1], dp[0] = dp\[0][0]**

   * **物品 2** 

     * **背包容量 4，dp[4] = dp\[2][4] = 35**

       dp[4] = Max{dp[4], v[2] + dp[4 - w[2]]} = Max{**dp[4]**, v[2] + **dp[2]**} = Max{15, 35} = 35

       dp\[2][4] = Max{dp\[1][4], v[2] + dp\[1][4 - w[2]]} = Max{**dp\[1][4]**, v[2] + **dp\[1][2]**} = Max{15, 35} = 35

       右侧，dp[4] = dp\[1][4], dp[2] = dp\[1][2]。

       如果背包容量也从前往后，则 dp[2] = dp\[2][4] != dp\[1][4] 即物品被重复放入，因此背包要从后往前。**倒序遍历的原因，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，因此需要从右向左覆盖。**

       **若是先遍历背包，后遍历物品。同样没有左上角的值。由于变成了一维数组，所以一定得先遍历物品，保证整行覆盖（脑补二维图，遍历顺序实际上就为了保证右下角依赖左上角）。**

       想图表理解简单。

     * **背包容量 3，dp[3] = dp\[2][3] = 35**

       dp[3] = Max{dp[3], v[2] + dp[3 - w[2]]} = Max{**dp[3]**, v[2] + **dp[1]**}

       dp\[2][3] = Max{dp\[1][3], v[2] + dp\[1][3 - w[2]]} = Max{**dp\[1][3]**, v[2] + **dp\[1][1]**}

       右侧，**dp[1] = dp\[1][1]**， **dp[3] = dp\[1][3]**，

     * **背包容量 2，dp[2] = dp\[2][2] = 20**

       dp[2] = Max{dp[2], v[2] + dp[2 - w[2]]} = Max{**dp[2]**, v[2] + **dp[0]**}

       dp\[2][2] = Max{dp\[1][2], v[2] + dp\[1][2 - w[2]]} = Max{**dp\[1][2]**, v[2] + **dp\[1][0]**}
     
       其中，右侧 **dp[2] = dp\[1][2]**，**dp[0] = dp\[1][0]** 。因此，前一个 dp[2] 和 dp[0] 应该是 i = 1 的结果，即依赖：物品1，背包所有容量数据。
     
     * **背包容量 1，dp[1] = dp\[2][1] = 15**
     
       dp[1] = Max{dp[1], v[1] + dp[1 - w[1]]} = Max{**dp[1]**, v[1] + **dp[0]}**
     
       dp\[1][1] = Max{dp\[0][1], v[1] + dp\[0][1 - w[1]]} = Max{**dp\[0][1]**, v[1] + **dp\[0][0]**}
     
       其中，右侧 **dp[1] = dp\[0][1]，dp[0] = dp\[0][0]**。
     
   * **物品 3**

     * 背包容量 4，dp[4] = dp\[3][4] = 35

     * 背包容量 3，dp[3] = dp\[3][3] = 35

       dp[3] = Max{dp[3], v[3] + dp\[2][3 - w[3]]}

     * 背包容量 2，dp[2] = dp\[3][2] = 20

     * 背包容量 1，dp[1] = dp\[3][1] = 15 


   ##### 4.2 先背包容量后物品，物品从前往后，背包容量从后往前

### Key

#### 遍历顺序

* 先物品，后背包：保证整行覆盖
* 背包从后向前：保证右下角依赖左上角

### Code

```java
public int knapsack01OneDim(int[] w, int[] v, int bagSize) {
        int goodsCount = w.length - 1;
        int[] dp = new int[bagSize + 1];
        for (int i = 1; i <= goodsCount; i++) {
            for (int b = bagSize; b >= w[i]; b--) {
                int notPutI = dp[b];// dp[b] = dp[i - 1][b];
                int putI = v[i] + dp[b - w[i]];// dp[b - w[i]] = dp[i - 1][b - w[i]];
                dp[b] = Math.max(notPutI, putI);
            }
        }
        System.out.println(Arrays.toString(dp));
        return dp[bagSize];
    }
```



### 心得体会

联系图标很重要，单从实际情况分析很复杂，但是从图表出发，明确原则，情况就能分的很快了。

高效 = 联系图表