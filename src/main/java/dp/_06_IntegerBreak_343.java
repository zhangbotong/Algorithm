package dp;

import org.junit.jupiter.api.Test;

/**
 * @author Kyrie
 * @date 2023/4/10 14:06
 */
public class _06_IntegerBreak_343 {
    /**
     * 问题：
     * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
     * 示例 1:
     * 输入: 2
     * 输出: 1
     * 解释: 2 = 1 + 1, 1 × 1 = 1。
     * 示例 2:
     *
     * 输入: 10
     * 输出: 36
     * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
     * 说明: 你可以假设 n 不小于 2 且不大于 58
     *
     * 解题思路：
     * DP 五部曲
     * 1、确定 dp 数组及下标含义：dp[i] 表示将数字 i 拆分成至少两个正整数的和，且这些整数的乘积最大值
     * 2、确定递推公式：dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
     *      为什么不用拆 dp[j]：可以理解j是拆分i的第一个整数，例如 i= 10，j = 5，i-j = 5，如果把j拆分为 2 和 3，其实在j = 2 的时候，i-j= 8 ，拆分i-j的时候就可以拆出来一个3了。
     * 3、dp 数组初始化：dp[1] = 1
     * 4、确定遍历顺序：从前向后
     * 5、举例推导 dp 数组
     *
     * key：分为两部分，一是拆成两数，二是拆成三数及以上。
     * 因为 dp[i - j] 至少是两数积，j * dp[i - j] 至少是 3 数，所以少了两数需要比较 max(j * (i - j), j * dp[i - j])
     */
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            /**
             * 判断条件如果是 j < i 容易理解，为什么可以优化成 j <= i/2 ?（较复杂可以先不剪枝）
             * 首先，对于拆成两个数的情况，根据数学推导一定是拆成两个最接近的数乘积最大，因此不必继续
             * 然后，对于拆成三个及以上的情况，其实前边已经都包含了，例如 10 = 6 + 4,6 * dp[4]: 6 * 1 * 3 或 6 * 2 * 2 这两种情况前边都包含了，因此可以剪枝
              */
            for (int j = 1; j <= i/2; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }

    @Test
    public void test() {
        System.out.println(integerBreak(10));
    }
}
